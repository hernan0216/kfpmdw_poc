import json

import kfp.dsl as _kfp_dsl
import kfp.components as _kfp_components

from collections import OrderedDict
from kubernetes import client as k8s_client

{# PIPELINE LIGHTWEIGHT COMPONENTS #}
{% for func in lightweight_components -%}
{{func}}
{% endfor -%}

{# DEFINE PIPELINE TASKS FROM FUNCTIONS #}
{%- for name in pipeline.steps_names -%}
{% if docker_image != '' %}
{{ name }}_op = _kfp_components.func_to_container_op({{ name }}, base_image='{{ docker_image }}')
{% else %}
{{ name }}_op = _kfp_components.func_to_container_op({{ name }})
{% endif %}
{% endfor -%}

{# DECLARE PIPELINE #}
@_kfp_dsl.pipeline(
   name='{{ pipeline_name }}',
   description='{{ pipeline_description }}'
)
    {% for step in pipeline.steps %}
    {{ step.name }}_task = _kale_{{ step.name }}_op({{ pipeline.all_steps_parameters[step.name]|join(', ') }})\
                                 .add_pvolumes(_kale_pvolumes_dict)\
                                 .after({{ pipeline.pipeline_dependencies_tasks[ step.name ]|map('add_prefix', '_kale_')|map('add_suffix', '_task')|join(', ') }})
    {%- if step.name != "final_auto_snapshot" and step.name != "pipeline_metrics" %}
    _output_artifacts.update({'mlpipeline-ui-metadata': '/mlpipeline-ui-metadata.json'})
    _output_artifacts.update({'{{ step.name }}': '/{{ step.name }}.html'})
    {%- endif %}
    _{{ step.name }}_task.output_artifact_paths.update(_kale_output_artifacts)
    _{{ step.name }}_task.add_pod_label("pipelines.kubeflow.org/metadata_written", "true")
    {%- endfor %}

{# The script will deploy the pipeline if run manually #}
if __name__ == "__main__":
    pipeline_func = auto_generated_pipeline
    pipeline_filename = pipeline_func.__name__ + '.pipeline.tar.gz'
    import kfp.compiler as compiler
    compiler.Compiler().compile(pipeline_func, pipeline_filename)

    # Get or create an experiment and submit a pipeline run
    import kfp
    client = kfp.Client()
    experiment = client.create_experiment('{{ experiment_name }}')

    # Submit a pipeline run
    run_name = generate_run_name('{{ pipeline_name }}')
    run_result = client.run_pipeline(experiment.id, run_name, pipeline_filename, {})
